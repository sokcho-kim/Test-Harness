# 작업일지 - 2026-01-22

## 작업 요약

Phase 2 백엔드 구현 - 로드맵 수립 + API 구현 + LLM 연동 + 테스트 실행

---

## 오전: 로드맵 v2 수립

### 참고 자료 분석
- Naver D2: 프롬프트 엔지니어링 도구 개발 경험기
- 우아한형제들: AI플랫폼 2.0 LLMOps

### 핵심 인사이트

| 출처 | 핵심 개념 | 적용 |
|------|----------|------|
| Naver D2 | 프롬프트 버저닝 (active 1개) | ✅ 적용 |
| Naver D2 | Application = Model + Prompt + Options | Phase 3 |
| Naver D2 | Ragas/ARES 평가 메트릭 | Phase 3 |
| 우아한 | Langfuse (프롬프트 관리) | Phase 4 |
| 우아한 | LiteLLM (통합 인터페이스) | Phase 4 |
| 우아한 | Golden/Evaluation Dataset 분리 | ✅ 적용 |
| Fastcampus | Semantic Versioning | ✅ 적용 |
| Gemini 분석 | 3단계 Fallback 매핑 | ✅ 적용 |

### 산출물
- `docs/roadmap-v2.md` - 로드맵 v2 문서

---

## 오후: Phase 2 백엔드 구현

### 1. 모델 확장 (`shared/core/models.py`)

```python
class PromptVersion:
    # Semantic Versioning (Major.Minor.Patch)
    major: int = 1
    minor: int = 0
    patch: int = 0
    is_active: bool = False

class TestDataset:
    dataset_type: DatasetType  # golden, evaluation, synthetic
    column_mapping: dict[str, str] | None  # 2순위 매핑

class TestCase:
    raw_input: dict[str, Any]  # 불변 원본 데이터
    expected_output: str | None
```

### 2. 3단계 Fallback 매핑 (`shared/core/mapping.py`)

```
1순위: TestRunRequest.column_mapping (실행 시점 오버라이드)
2순위: TestDataset.column_mapping (데이터셋 기본값)
3순위: 1:1 Fallback (컬럼명 = 변수명)
```

**설계 철학:**
- Convention over Configuration (Rails 철학)
- Data Immutability (raw_input 보존)
- Non-developer Friendly (자동 매핑)

### 3. API 라우터 구현

| 라우터 | 엔드포인트 | 주요 기능 |
|--------|-----------|----------|
| `/prompts` | CRUD + versions | Semantic Versioning |
| `/datasets` | CRUD + import/export | CSV/JSON Import |
| `/tests` | run + execute + results | 3단계 매핑 |

### 4. Together AI Adapter (`shared/adapters/together_ai.py`)

```python
from shared.adapters import create_together_adapter

adapter = create_together_adapter()  # .env의 TOGETHER_API_KEY
response = await adapter.generate(
    prompt="질문",
    model="meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo",
)
```

**지원 모델:**
- `llama-3.3-70b`, `llama-3.1-8b`, `llama-3.1-70b`
- `mixtral-8x7b`, `mixtral-8x22b`
- `qwen-2.5-72b`, `deepseek-v3`, `deepseek-r1`

### 5. promptfoo 연동

**설치:**
```bash
npm install promptfoo --save-dev  # 프로젝트 의존성
```

**PromptfooRunner** (`shared/core/promptfoo_runner.py`):
```python
runner = PromptfooRunner(project_root=Path.cwd())
results = await runner.run_and_parse(
    prompts=[{"id": "p1", "content": "{{q}}"}],
    model_ids=["meta-llama/..."],
    tests=[{"vars": {"q": "2+2?"}, "assert": [{"type": "contains", "value": "4"}]}],
)
```

### 6. 테스트 실행 API

**엔드포인트:** `POST /tests/{id}/execute`

```bash
# 동기 실행
curl -X POST "http://localhost:8000/tests/run_xxx/execute?sync=true"

# 응답
{
  "test_run_id": "run_xxx",
  "status": "completed",
  "total_results": 2,
  "passed": 2,
  "failed": 0
}
```

---

## 테스트 결과

### 전체 E2E 테스트 성공

| 단계 | API | 결과 |
|------|-----|------|
| 1 | POST /prompts | ✅ 프롬프트 생성 + 변수 추출 |
| 2 | POST /datasets | ✅ 데이터셋 생성 |
| 3 | POST /datasets/{id}/cases | ✅ 케이스 추가 |
| 4 | POST /tests/run | ✅ 테스트 실행 생성 + 매핑 |
| 5 | POST /tests/{id}/execute | ✅ LLM 호출 + 결과 저장 |
| 6 | GET /tests/{id}/results | ✅ 결과 조회 |

**실제 LLM 응답:**
| 입력 | 출력 | Latency |
|------|------|---------|
| Calculate: 2+2 | 2 + 2 = 4 | 809ms |
| Calculate: 10*5 | 10 * 5 = 50 | 591ms |

---

## 파일 구조 (신규/수정)

```
shared/
├── adapters/
│   └── together_ai.py       # NEW: Together AI 헬퍼
├── core/
│   ├── mapping.py           # NEW: 3단계 Fallback 매핑
│   └── promptfoo_runner.py  # NEW: promptfoo 실행기
└── database/
    └── database.py          # UPDATED: 스키마 v2

services/api/src/test_harness_api/
├── routers/
│   ├── tests.py             # UPDATED: execute 엔드포인트
│   ├── prompts.py           # NEW: 버전 관리 API
│   └── datasets.py          # NEW: Import/Export API
└── services/
    ├── test_executor.py     # NEW: 테스트 실행 로직
    ├── prompt_service.py    # NEW: 프롬프트 서비스
    └── dataset_service.py   # NEW: 데이터셋 서비스

package.json                  # NEW: promptfoo 의존성
```

---

## 환경 설정

**.env 필수:**
```
TOGETHER_API_KEY=your_api_key
```

---

## 저녁: Assertion 시스템 구현 (Option C)

### 설계 결정 (Gemini 분석 기반)

**3단계 Assertion 병합 전략:**
```
1순위: Dataset.default_assertions (Base - 전체 케이스 적용)
2순위: Case.assertions (Override/Add - 개별 케이스)
3순위: expected_output → contains (Safety Net - 자동 생성)
```

**병합 규칙:**
- 같은 type+value의 assertion → Case 것으로 Override
- 다른 type의 assertion → Add
- expected_output이 있고 동일한 contains가 없으면 자동 생성

### 구현 내용

#### 1. DB 스키마 v3 (`shared/database/database.py`)

```sql
-- test_datasets 테이블에 추가
default_assertions TEXT DEFAULT '[]'

-- test_cases 테이블에 추가
assertions TEXT
```

#### 2. 모델 확장 (`shared/core/models.py`)

```python
class TestDataset(BaseModel):
    # 기본 Assertion (모든 케이스에 적용)
    default_assertions: list[Assertion] = Field(default_factory=list)

class TestCase(BaseModel):
    # 케이스별 Assertion (Override/Add)
    assertions: list[Assertion] | None = None
```

#### 3. AssertionMerger (`shared/core/mapping.py`)

```python
class AssertionMerger:
    @staticmethod
    def merge_assertions(
        dataset_assertions: list | None,
        case_assertions: list | None,
        expected_output: str | None = None,
    ) -> list[dict]:
        # 1. Dataset assertions (Base)
        # 2. Case assertions (Override/Add)
        # 3. expected_output → contains (Safety Net)
```

#### 4. TestExecutor 업데이트

```python
# 3단계 Assertion 병합
merged_assertions = AssertionMerger.merge_assertions(
    dataset_assertions=dataset_assertions,
    case_assertions=case.get("assertions"),
    expected_output=case.get("expected_output"),
)
```

#### 5. API 엔드포인트 업데이트

| 엔드포인트 | 필드 추가 |
|-----------|----------|
| POST /datasets | `default_assertions` |
| PUT /datasets/{id} | `default_assertions` |
| POST /datasets/{id}/cases | `assertions` |

### 사용 예시

```bash
# 1. 데이터셋 생성 (기본 assertions 포함)
curl -X POST "http://localhost:8000/datasets" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "QA Dataset",
    "default_assertions": [
      {"type": "not-contains", "value": "죄송합니다"},
      {"type": "is-json"}
    ]
  }'

# 2. 케이스 추가 (개별 assertions 포함)
curl -X POST "http://localhost:8000/datasets/{id}/cases" \
  -H "Content-Type: application/json" \
  -d '{
    "raw_input": {"question": "서울의 인구는?"},
    "expected_output": "1000만",
    "assertions": [
      {"type": "contains", "value": "서울"},
      {"type": "llm-rubric", "value": "정확한 숫자가 포함되어야 함"}
    ]
  }'
```

### 병합 결과 예시

```python
# Dataset: [not-contains:sorry, is-json]
# Case: [contains:4, llm-rubric:수학적으로 정확해야 함]
# expected_output: "4"

# 병합 결과:
[
  {"type": "not-contains", "value": "sorry"},   # Base
  {"type": "is-json"},                          # Base
  {"type": "contains", "value": "4"},           # Case
  {"type": "llm-rubric", "value": "..."}        # Case
  # expected_output의 contains:4는 이미 있으므로 추가 안됨
]
```

---

## 해결된 이슈

### 1. 결과 매핑 정확도 ✅
- **해결:** promptfoo config에 `label` 필드로 prompt ID 추적
- **해결:** `__case_id__` 히든 필드로 case ID 추적

### 2. Assertion 시스템 ✅
- **해결:** 3단계 Assertion 병합 (Dataset → Case → expected_output)

---

## 파일 구조 (추가/수정)

```
shared/core/
├── mapping.py              # UPDATED: AssertionMerger 추가
└── models.py               # UPDATED: assertions 필드 추가

shared/database/
└── database.py             # UPDATED: 스키마 v3 (assertions 컬럼)

services/api/src/test_harness_api/
├── routers/
│   └── datasets.py         # UPDATED: assertions API
├── services/
│   ├── dataset_service.py  # UPDATED: assertions CRUD
│   └── test_executor.py    # UPDATED: AssertionMerger 사용
```

---

## 다음 작업

- [x] 로드맵 v2 수립
- [x] 모델 확장 (PromptVersion, TestDataset)
- [x] 3단계 Fallback 매핑
- [x] API 라우터 (prompts, datasets, tests)
- [x] Together AI Adapter
- [x] promptfoo 연동
- [x] 테스트 실행 API
- [x] 결과 매핑 정확도 개선
- [x] Assertion 시스템 (Option C)
- [ ] 커밋
